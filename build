#!/bin/bash

# termiate script on error:
set -e

#######################################
# FUNCTIONS
#######################################

function check_need_update {
  dest="$1"
  # target exists?
  [ -f "$dest" ] || return 0
  shift 1
  # target older than dependencies?
  for n in $@; do
    [ "$dest" -ot "$n" ] && return 0
  done
  # target is up to date: return non-zero exit code
  return 1
}


function compile {
  echo "[CC]" g++ -Wall $cflags -c -I. "$1" -o "${1%.*}.o"
  g++ -Wall $cflags -c -I. "$1" -o "${1%.*}.o"
}



function link {
  echo "[LD]" g++ $cflags *.o -o "$1"
  g++ $cflags *.o -o "$1"
}


function get_executable_name {
  # figure out target executable based on which cpp file contains 'main':
  exe=( "$(grep -l 'int *main *(.*)' *.cpp )" )
  [ ${#exe[@]} -gt 1 ] && echo "error: main() defined in multiple cpp files: "$exe[*] && exit 1

  exe="${exe[*]}"
  echo ${exe%.cpp}
}




#######################################
# CMDLINE PARSING
#######################################


# debug by default:
cflags="-g"

for arg in "$@"; do
  case $arg in
    "nodebug") 
      cflags="-O2"
      ;;
    "clean")
      exe="$(get_executable_name)"
      [ -f "$exe" ] && rm -vf  "$exe"
      rm -vf *.o
      exit 0
      ;;
    *)
      echo "unknown argument \"$arg\""
      exit 1
      ;;
  esac
done




#######################################
# MAIN SCRIPT
#######################################

# compile all C++ files into objects first:
for cpp in *.cpp; do
  check_need_update "${cpp%.*}.o" "$cpp" && compile "$cpp"
done

# guess executable name:
target="$(get_executable_name)"

# link all objects into target:
check_need_update "$target" *.o || exit 0
link "$target"

